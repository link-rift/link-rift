# Development Guide

> Last Updated: 2025-01-24

Development workflow, coding standards, and best practices for Linkrift.

## Table of Contents

- [Project Structure](#project-structure)
- [Development Workflow](#development-workflow)
- [Code Organization](#code-organization)
- [Naming Conventions](#naming-conventions)
- [Git Workflow](#git-workflow)
- [Testing](#testing)
- [Database Workflow](#database-workflow)
- [Debugging](#debugging)
- [Makefile Commands](#makefile-commands)

---

## Project Structure

```
linkrift/
├── cmd/                          # Application entry points
│   ├── api/main.go               # Main API server
│   ├── redirect/main.go          # Optimized redirect service
│   ├── worker/main.go            # Background job processor
│   ├── scheduler/main.go         # Cron job service
│   └── cli/main.go               # CLI tool
│
├── internal/                     # Private application code
│   ├── config/                   # Configuration (Viper)
│   ├── database/                 # Database connections
│   ├── models/                   # Domain models
│   ├── repository/               # Data access layer
│   │   └── sqlc/                 # Generated by sqlc
│   ├── service/                  # Business logic
│   ├── handler/                  # HTTP handlers (Gin)
│   ├── middleware/               # HTTP middleware
│   ├── worker/                   # Background job definitions
│   ├── redirect/                 # Redirect service logic
│   ├── license/                  # License verification
│   └── ee/                       # Enterprise features
│
├── pkg/                          # Public packages
│   ├── validator/                # Custom validators
│   ├── paseto/                   # PASETO token helpers
│   ├── shortcode/                # Short code generation
│   └── httputil/                 # HTTP utilities
│
├── web/                          # React frontend
│   ├── src/
│   │   ├── components/           # React components
│   │   ├── pages/                # Page components
│   │   ├── hooks/                # Custom hooks
│   │   ├── stores/               # Zustand stores
│   │   ├── services/             # API clients
│   │   └── types/                # TypeScript types
│   ├── vite.config.ts
│   └── tailwind.config.ts
│
├── migrations/                   # Database migrations
│   ├── postgres/
│   └── clickhouse/
│
├── sqlc/                         # sqlc configuration
│   ├── sqlc.yaml
│   ├── queries/                  # SQL query files
│   └── schema.sql
│
├── deployments/                  # Deployment configs
│   ├── docker-compose.yml
│   └── kubernetes/
│
├── .air.toml                     # Hot reload config
├── .golangci.yml                 # Linter config
├── Makefile                      # Build commands
└── go.mod
```

---

## Development Workflow

### Starting Development Environment

```bash
# 1. Start infrastructure
docker compose up -d postgres redis clickhouse meilisearch

# 2. Run migrations
make migrate-up

# 3. Start backend with hot reload
make dev-api

# 4. Start frontend (in another terminal)
make dev-web
```

### Hot Reload Configuration

Backend uses [air](https://github.com/air-verse/air) for hot reload:

```toml
# .air.toml
root = "."
tmp_dir = "tmp"

[build]
cmd = "go build -o ./tmp/api ./cmd/api"
bin = "./tmp/api"
include_ext = ["go", "tpl", "tmpl", "html"]
exclude_dir = ["tmp", "vendor", "web", "node_modules"]
delay = 1000

[log]
time = false

[misc]
clean_on_exit = true
```

Frontend uses Vite's built-in HMR.

### Code Quality Checks

```bash
# Before committing
make lint          # Run golangci-lint
make fmt           # Format code with gofmt
make vet           # Run go vet
make test          # Run tests
```

---

## Code Organization

### Go Code Principles

1. **cmd/** — Entry points only, minimal logic
2. **internal/** — Private packages, cannot be imported externally
3. **pkg/** — Public packages, can be imported by other projects

### Handler Pattern

```go
// internal/handler/link_handler.go
package handler

type LinkHandler struct {
    linkService service.LinkService
    logger      *zap.Logger
}

func NewLinkHandler(ls service.LinkService, log *zap.Logger) *LinkHandler {
    return &LinkHandler{
        linkService: ls,
        logger:      log,
    }
}

func (h *LinkHandler) Create(c *gin.Context) {
    var req CreateLinkRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }

    userID := middleware.GetUserID(c)
    link, err := h.linkService.Create(c.Request.Context(), userID, req.ToCreateInput())
    if err != nil {
        h.handleError(c, err)
        return
    }

    c.JSON(http.StatusCreated, LinkResponse{}.FromModel(link))
}
```

### Service Pattern

```go
// internal/service/link_service.go
package service

type LinkService interface {
    Create(ctx context.Context, userID string, input CreateLinkInput) (*models.Link, error)
    GetByID(ctx context.Context, id string) (*models.Link, error)
    GetByCode(ctx context.Context, code string) (*models.Link, error)
    List(ctx context.Context, userID string, opts ListOptions) ([]*models.Link, error)
    Update(ctx context.Context, id string, input UpdateLinkInput) (*models.Link, error)
    Delete(ctx context.Context, id string) error
}

type linkService struct {
    repo   repository.LinkRepository
    cache  cache.Cache
    logger *zap.Logger
}

func NewLinkService(repo repository.LinkRepository, cache cache.Cache, log *zap.Logger) LinkService {
    return &linkService{
        repo:   repo,
        cache:  cache,
        logger: log,
    }
}
```

### Repository Pattern

```go
// internal/repository/link_repo.go
package repository

type LinkRepository interface {
    Create(ctx context.Context, link *models.Link) error
    GetByID(ctx context.Context, id string) (*models.Link, error)
    GetByCode(ctx context.Context, code string) (*models.Link, error)
    List(ctx context.Context, userID string, opts ListOptions) ([]*models.Link, int64, error)
    Update(ctx context.Context, link *models.Link) error
    Delete(ctx context.Context, id string) error
}

type linkRepository struct {
    db      *sqlc.Queries
    logger  *zap.Logger
}

func NewLinkRepository(db *sqlc.Queries, log *zap.Logger) LinkRepository {
    return &linkRepository{db: db, logger: log}
}
```

---

## Naming Conventions

### Go

| Type | Convention | Example |
|------|------------|---------|
| Package | lowercase, short | `handler`, `service` |
| Interface | PascalCase, noun | `LinkService`, `UserRepository` |
| Struct | PascalCase | `LinkHandler`, `CreateLinkInput` |
| Function | PascalCase (exported) | `CreateLink`, `GetByID` |
| Function | camelCase (unexported) | `parseRequest`, `validateInput` |
| Variable | camelCase | `linkService`, `userID` |
| Constant | PascalCase or ALL_CAPS | `MaxRetries`, `DEFAULT_TIMEOUT` |
| File | snake_case | `link_handler.go`, `auth_service.go` |

### TypeScript/React

| Type | Convention | Example |
|------|------------|---------|
| Component | PascalCase | `LinkCard`, `Dashboard` |
| Hook | camelCase with "use" prefix | `useAuth`, `useLinks` |
| Store | camelCase with "Store" suffix | `authStore`, `uiStore` |
| Type/Interface | PascalCase | `Link`, `CreateLinkRequest` |
| File (component) | PascalCase | `LinkCard.tsx` |
| File (hook/util) | camelCase | `useAuth.ts`, `utils.ts` |

### Database

| Type | Convention | Example |
|------|------------|---------|
| Table | snake_case, plural | `users`, `links`, `workspace_members` |
| Column | snake_case | `user_id`, `created_at`, `short_code` |
| Index | `idx_<table>_<columns>` | `idx_links_user_id`, `idx_links_short_code` |
| Foreign Key | `fk_<table>_<ref_table>` | `fk_links_users` |

---

## Git Workflow

### Branch Naming

```
main              # Production-ready code
develop           # Integration branch
feature/<name>    # New features
bugfix/<name>     # Bug fixes
hotfix/<name>     # Production hotfixes
release/<version> # Release preparation
```

### Commit Messages

Follow [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

Types:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation
- `style`: Formatting (no code change)
- `refactor`: Code restructuring
- `test`: Adding tests
- `chore`: Maintenance

Examples:

```bash
feat(links): add bulk import functionality
fix(redirect): handle missing short code gracefully
docs(api): update authentication examples
refactor(service): extract validation logic
test(handler): add link creation tests
chore(deps): update Go dependencies
```

### Pull Request Process

1. Create feature branch from `develop`
2. Make changes with clear commits
3. Run tests and linting locally
4. Push branch and open PR
5. Request review from team
6. Address feedback
7. Squash and merge

---

## Testing

### Test Structure

```
internal/
├── service/
│   ├── link_service.go
│   └── link_service_test.go    # Unit tests
├── handler/
│   ├── link_handler.go
│   └── link_handler_test.go    # Handler tests
└── repository/
    ├── link_repo.go
    └── link_repo_test.go       # Integration tests
```

### Table-Driven Tests

```go
func TestLinkService_Create(t *testing.T) {
    tests := []struct {
        name      string
        input     CreateLinkInput
        setupMock func(*mocks.MockLinkRepository)
        wantErr   bool
        errType   error
    }{
        {
            name: "valid link creation",
            input: CreateLinkInput{
                URL:        "https://example.com",
                CustomCode: "test123",
            },
            setupMock: func(m *mocks.MockLinkRepository) {
                m.EXPECT().GetByCode(gomock.Any(), "test123").Return(nil, nil)
                m.EXPECT().Create(gomock.Any(), gomock.Any()).Return(nil)
            },
            wantErr: false,
        },
        {
            name: "duplicate code",
            input: CreateLinkInput{
                URL:        "https://example.com",
                CustomCode: "existing",
            },
            setupMock: func(m *mocks.MockLinkRepository) {
                m.EXPECT().GetByCode(gomock.Any(), "existing").Return(&models.Link{}, nil)
            },
            wantErr: true,
            errType: ErrCodeAlreadyExists,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ctrl := gomock.NewController(t)
            defer ctrl.Finish()

            mockRepo := mocks.NewMockLinkRepository(ctrl)
            tt.setupMock(mockRepo)

            svc := NewLinkService(mockRepo, nil, zap.NewNop())
            _, err := svc.Create(context.Background(), "user-1", tt.input)

            if tt.wantErr {
                assert.Error(t, err)
                if tt.errType != nil {
                    assert.ErrorIs(t, err, tt.errType)
                }
            } else {
                assert.NoError(t, err)
            }
        })
    }
}
```

### HTTP Handler Tests

```go
func TestLinkHandler_Create(t *testing.T) {
    gin.SetMode(gin.TestMode)

    mockService := mocks.NewMockLinkService(ctrl)
    handler := NewLinkHandler(mockService, zap.NewNop())

    router := gin.New()
    router.POST("/links", handler.Create)

    body := `{"url": "https://example.com"}`
    req := httptest.NewRequest("POST", "/links", strings.NewReader(body))
    req.Header.Set("Content-Type", "application/json")

    w := httptest.NewRecorder()
    router.ServeHTTP(w, req)

    assert.Equal(t, http.StatusCreated, w.Code)
}
```

### Running Tests

```bash
# All tests
make test

# With coverage
make test-cover

# Specific package
go test -v ./internal/service/...

# Single test
go test -v -run TestLinkService_Create ./internal/service/...

# With race detection
go test -race ./...

# Benchmarks
go test -bench=. ./internal/redirect/...
```

---

## Database Workflow

### Creating Migrations

```bash
# Create new migration
make migrate-create name=add_workspaces

# This creates:
# migrations/postgres/000002_add_workspaces.up.sql
# migrations/postgres/000002_add_workspaces.down.sql
```

### Writing Migrations

```sql
-- 000002_add_workspaces.up.sql
CREATE TABLE workspaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) NOT NULL UNIQUE,
    owner_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_workspaces_owner_id ON workspaces(owner_id);
CREATE INDEX idx_workspaces_slug ON workspaces(slug);
```

```sql
-- 000002_add_workspaces.down.sql
DROP TABLE IF EXISTS workspaces;
```

### sqlc Workflow

1. Write SQL queries in `sqlc/queries/`:

```sql
-- sqlc/queries/links.sql

-- name: GetLinkByCode :one
SELECT * FROM links
WHERE short_code = $1 AND deleted_at IS NULL;

-- name: CreateLink :one
INSERT INTO links (user_id, workspace_id, url, short_code, title)
VALUES ($1, $2, $3, $4, $5)
RETURNING *;

-- name: ListLinksByUser :many
SELECT * FROM links
WHERE user_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3;
```

2. Generate Go code:

```bash
make sqlc
```

3. Use generated code:

```go
link, err := queries.GetLinkByCode(ctx, "abc123")
```

---

## Debugging

### VS Code Launch Configuration

```json
// .vscode/launch.json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug API",
            "type": "go",
            "request": "launch",
            "mode": "auto",
            "program": "${workspaceFolder}/cmd/api",
            "env": {
                "APP_ENV": "development"
            },
            "args": []
        },
        {
            "name": "Debug Tests",
            "type": "go",
            "request": "launch",
            "mode": "test",
            "program": "${file}"
        }
    ]
}
```

### Delve Debugging

```bash
# Install Delve
go install github.com/go-delve/delve/cmd/dlv@latest

# Debug API
dlv debug ./cmd/api

# Debug test
dlv test ./internal/service/...
```

### pprof Profiling

```go
// Enable pprof endpoints in development
import _ "net/http/pprof"

// In main.go
go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()
```

```bash
# CPU profile
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# Memory profile
go tool pprof http://localhost:6060/debug/pprof/heap

# Goroutine profile
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

---

## Makefile Commands

```bash
# Development
make dev              # Run all services with hot reload
make dev-api          # Run API server with air
make dev-redirect     # Run redirect service with air
make dev-worker       # Run worker with air
make dev-web          # Run Vite dev server

# Build
make build            # Build all Go binaries
make build-api        # Build API binary
make build-redirect   # Build redirect binary
make build-web        # Build frontend

# Database
make migrate-up       # Run pending migrations
make migrate-down     # Rollback last migration
make migrate-create   # Create new migration files
make migrate-status   # Show migration status
make sqlc             # Generate sqlc code
make seed             # Seed development data

# Testing
make test             # Run all tests
make test-unit        # Run unit tests only
make test-integration # Run integration tests
make test-e2e         # Run E2E tests
make test-cover       # Run tests with coverage report
make bench            # Run benchmarks

# Code Quality
make lint             # Run golangci-lint
make fmt              # Format Go code
make vet              # Run go vet
make security         # Run security checks (gosec, govulncheck)

# Docker
make docker-build     # Build all Docker images
make docker-up        # Start Docker Compose
make docker-down      # Stop Docker Compose
make docker-logs      # View container logs

# Utilities
make clean            # Remove build artifacts
make deps             # Update dependencies
make generate         # Run go generate
make docs             # Generate API documentation
make help             # Show available commands
```

---

## Next Steps

- [Architecture](../architecture/ARCHITECTURE.md) — System design
- [Go Patterns](../architecture/GO_PATTERNS.md) — Go-specific patterns
- [Testing Guide](../testing/TESTING.md) — Comprehensive testing
- [API Documentation](../api/API_DOCUMENTATION.md) — API reference

---

**Need help?** Open an issue on [GitHub](https://github.com/link-rift/link-rift/issues).
