// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: links.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLink = `-- name: CreateLink :one
INSERT INTO links (
    user_id, workspace_id, domain_id, url, short_code,
    title, description, is_active, password_hash,
    expires_at, max_clicks,
    utm_source, utm_medium, utm_campaign, utm_term, utm_content
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, user_id, workspace_id, domain_id, url, short_code, title, description, favicon_url, og_image_url, is_active, password_hash, expires_at, max_clicks, utm_source, utm_medium, utm_campaign, utm_term, utm_content, total_clicks, unique_clicks, created_at, updated_at, deleted_at
`

type CreateLinkParams struct {
	UserID       uuid.UUID          `json:"user_id"`
	WorkspaceID  uuid.UUID          `json:"workspace_id"`
	DomainID     pgtype.UUID        `json:"domain_id"`
	Url          string             `json:"url"`
	ShortCode    string             `json:"short_code"`
	Title        pgtype.Text        `json:"title"`
	Description  pgtype.Text        `json:"description"`
	IsActive     bool               `json:"is_active"`
	PasswordHash pgtype.Text        `json:"password_hash"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	MaxClicks    pgtype.Int4        `json:"max_clicks"`
	UtmSource    pgtype.Text        `json:"utm_source"`
	UtmMedium    pgtype.Text        `json:"utm_medium"`
	UtmCampaign  pgtype.Text        `json:"utm_campaign"`
	UtmTerm      pgtype.Text        `json:"utm_term"`
	UtmContent   pgtype.Text        `json:"utm_content"`
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, createLink,
		arg.UserID,
		arg.WorkspaceID,
		arg.DomainID,
		arg.Url,
		arg.ShortCode,
		arg.Title,
		arg.Description,
		arg.IsActive,
		arg.PasswordHash,
		arg.ExpiresAt,
		arg.MaxClicks,
		arg.UtmSource,
		arg.UtmMedium,
		arg.UtmCampaign,
		arg.UtmTerm,
		arg.UtmContent,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WorkspaceID,
		&i.DomainID,
		&i.Url,
		&i.ShortCode,
		&i.Title,
		&i.Description,
		&i.FaviconUrl,
		&i.OgImageUrl,
		&i.IsActive,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxClicks,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.UtmTerm,
		&i.UtmContent,
		&i.TotalClicks,
		&i.UniqueClicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getLinkByID = `-- name: GetLinkByID :one
SELECT id, user_id, workspace_id, domain_id, url, short_code, title, description, favicon_url, og_image_url, is_active, password_hash, expires_at, max_clicks, utm_source, utm_medium, utm_campaign, utm_term, utm_content, total_clicks, unique_clicks, created_at, updated_at, deleted_at FROM links
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetLinkByID(ctx context.Context, id uuid.UUID) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkByID, id)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WorkspaceID,
		&i.DomainID,
		&i.Url,
		&i.ShortCode,
		&i.Title,
		&i.Description,
		&i.FaviconUrl,
		&i.OgImageUrl,
		&i.IsActive,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxClicks,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.UtmTerm,
		&i.UtmContent,
		&i.TotalClicks,
		&i.UniqueClicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getLinkByShortCode = `-- name: GetLinkByShortCode :one
SELECT id, user_id, workspace_id, domain_id, url, short_code, title, description, favicon_url, og_image_url, is_active, password_hash, expires_at, max_clicks, utm_source, utm_medium, utm_campaign, utm_term, utm_content, total_clicks, unique_clicks, created_at, updated_at, deleted_at FROM links
WHERE short_code = $1 AND deleted_at IS NULL
`

func (q *Queries) GetLinkByShortCode(ctx context.Context, shortCode string) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkByShortCode, shortCode)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WorkspaceID,
		&i.DomainID,
		&i.Url,
		&i.ShortCode,
		&i.Title,
		&i.Description,
		&i.FaviconUrl,
		&i.OgImageUrl,
		&i.IsActive,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxClicks,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.UtmTerm,
		&i.UtmContent,
		&i.TotalClicks,
		&i.UniqueClicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const incrementLinkClicks = `-- name: IncrementLinkClicks :exec
UPDATE links
SET total_clicks = total_clicks + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementLinkClicks(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementLinkClicks, id)
	return err
}

const listLinksForWorkspace = `-- name: ListLinksForWorkspace :many
SELECT
    l.id, l.user_id, l.workspace_id, l.domain_id, l.url, l.short_code, l.title, l.description, l.favicon_url, l.og_image_url, l.is_active, l.password_hash, l.expires_at, l.max_clicks, l.utm_source, l.utm_medium, l.utm_campaign, l.utm_term, l.utm_content, l.total_clicks, l.unique_clicks, l.created_at, l.updated_at, l.deleted_at,
    COUNT(*) OVER() AS total_count
FROM links l
WHERE l.workspace_id = $1
    AND l.deleted_at IS NULL
    AND ($4::text IS NULL OR
         to_tsvector('english', COALESCE(l.title, '') || ' ' || COALESCE(l.description, '')) @@
         plainto_tsquery('english', $4::text))
ORDER BY l.created_at DESC
LIMIT $2 OFFSET $3
`

type ListLinksForWorkspaceParams struct {
	WorkspaceID uuid.UUID   `json:"workspace_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
	Search      pgtype.Text `json:"search"`
}

type ListLinksForWorkspaceRow struct {
	ID           uuid.UUID          `json:"id"`
	UserID       uuid.UUID          `json:"user_id"`
	WorkspaceID  uuid.UUID          `json:"workspace_id"`
	DomainID     pgtype.UUID        `json:"domain_id"`
	Url          string             `json:"url"`
	ShortCode    string             `json:"short_code"`
	Title        pgtype.Text        `json:"title"`
	Description  pgtype.Text        `json:"description"`
	FaviconUrl   pgtype.Text        `json:"favicon_url"`
	OgImageUrl   pgtype.Text        `json:"og_image_url"`
	IsActive     bool               `json:"is_active"`
	PasswordHash pgtype.Text        `json:"password_hash"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	MaxClicks    pgtype.Int4        `json:"max_clicks"`
	UtmSource    pgtype.Text        `json:"utm_source"`
	UtmMedium    pgtype.Text        `json:"utm_medium"`
	UtmCampaign  pgtype.Text        `json:"utm_campaign"`
	UtmTerm      pgtype.Text        `json:"utm_term"`
	UtmContent   pgtype.Text        `json:"utm_content"`
	TotalClicks  int64              `json:"total_clicks"`
	UniqueClicks int64              `json:"unique_clicks"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	TotalCount   int64              `json:"total_count"`
}

func (q *Queries) ListLinksForWorkspace(ctx context.Context, arg ListLinksForWorkspaceParams) ([]ListLinksForWorkspaceRow, error) {
	rows, err := q.db.Query(ctx, listLinksForWorkspace,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLinksForWorkspaceRow{}
	for rows.Next() {
		var i ListLinksForWorkspaceRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WorkspaceID,
			&i.DomainID,
			&i.Url,
			&i.ShortCode,
			&i.Title,
			&i.Description,
			&i.FaviconUrl,
			&i.OgImageUrl,
			&i.IsActive,
			&i.PasswordHash,
			&i.ExpiresAt,
			&i.MaxClicks,
			&i.UtmSource,
			&i.UtmMedium,
			&i.UtmCampaign,
			&i.UtmTerm,
			&i.UtmContent,
			&i.TotalClicks,
			&i.UniqueClicks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteLink = `-- name: SoftDeleteLink :exec
UPDATE links
SET deleted_at = NOW(), updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteLink(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteLink, id)
	return err
}

const updateLink = `-- name: UpdateLink :one
UPDATE links
SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    url = COALESCE($4, url),
    is_active = COALESCE($5, is_active),
    password_hash = COALESCE($6, password_hash),
    expires_at = COALESCE($7, expires_at),
    max_clicks = COALESCE($8, max_clicks),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, user_id, workspace_id, domain_id, url, short_code, title, description, favicon_url, og_image_url, is_active, password_hash, expires_at, max_clicks, utm_source, utm_medium, utm_campaign, utm_term, utm_content, total_clicks, unique_clicks, created_at, updated_at, deleted_at
`

type UpdateLinkParams struct {
	ID           uuid.UUID          `json:"id"`
	Title        pgtype.Text        `json:"title"`
	Description  pgtype.Text        `json:"description"`
	Url          pgtype.Text        `json:"url"`
	IsActive     pgtype.Bool        `json:"is_active"`
	PasswordHash pgtype.Text        `json:"password_hash"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	MaxClicks    pgtype.Int4        `json:"max_clicks"`
}

func (q *Queries) UpdateLink(ctx context.Context, arg UpdateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, updateLink,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Url,
		arg.IsActive,
		arg.PasswordHash,
		arg.ExpiresAt,
		arg.MaxClicks,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WorkspaceID,
		&i.DomainID,
		&i.Url,
		&i.ShortCode,
		&i.Title,
		&i.Description,
		&i.FaviconUrl,
		&i.OgImageUrl,
		&i.IsActive,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxClicks,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.UtmTerm,
		&i.UtmContent,
		&i.TotalClicks,
		&i.UniqueClicks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
